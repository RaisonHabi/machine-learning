## 参考文档1的推导图片
### 泰勒公式展开
泰勒公式是将一个在 x = x0 处具有n阶导数的函数 f(x) 利用关于 (x-x0) 的n次多项式来逼近函数的方法。 

泰勒公式一句话描述：就是用多项式函数去逼近光滑函数。  
[如何通俗地解释泰勒公式？ - 马同学的回答 - 知乎](https://www.zhihu.com/question/21149770/answer/111173412)

&nbsp;

<p><strong>从“目标函数”开始，生成一棵树</strong></p><h3 id="1.-XGB%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0" name="1.-XGB%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0"><strong>1. XGB目标函数</strong></h3><p>XGBoost的目标函数由<strong>训练损失</strong>和<strong>正则化项</strong>两部分组成，目标函数定义如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/6gihvpdvcw.jpeg"></span></div></figure><p><strong>变量解释：</strong></p><p>（1）l 代表损失函数，常见的损失函数有：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/ue12j9n237.jpeg"></span></div></figure><p>（2）yi&#x27;是第 i 个样本 xi 的预测值。由于XGBoost是一个加法模型，因此，预测得分是每棵树打分的累加之和。
</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/l5l6pukp4b.jpeg"></span></div></figure><p>（3）将全部k棵树的复杂度进行求和，添加到目标函数中作为正则化项，用于防止模型过度拟合。</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/lnlhtc1unp.png"></span></div></figure><h3 id="2.-%E5%AD%A6%E4%B9%A0%E7%AC%ACt%E6%A3%B5%E6%A0%91" name="2.-%E5%AD%A6%E4%B9%A0%E7%AC%ACt%E6%A3%B5%E6%A0%91"><strong>2. 学习第t棵树</strong></h3><p>在【1】中提到，XGBoost 是一个加法模型，假设我们第t次迭代要训练的树模型是 ft() ，则有：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/q1etr96l7p.jpeg"></span></div></figure><p>将上式带入【1】中的目标函数 Obj ，可以得到：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/koicxzag26.jpeg"></span></div></figure><p>注意上式中，只有一个变量，那就是第 t 棵树：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/oft3lgkmzz.png"></span></div></figure><p>其余的都是已知量或可通过已知量可以计算出来的（注意要理解哦！）。</p><p>细心的同学可以发现，这里我们将正则化项进行了拆分，由于前 t-1棵树的结构已经确定，因此，前 t-1 棵树的复杂度之和可以用一个常量表示：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/xcchsaerur.jpeg"></span></div></figure><h3 id="3.-%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E5%B1%95%E5%BC%80" name="3.-%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E5%B1%95%E5%BC%80"><strong>3. 泰勒公式展开</strong></h3><p>首先简单回忆一下，泰勒公式。</p><blockquote><p>泰勒公式是将一个在 x = x0 处具有n阶导数的函数 f(x) 利用关于 (x-x0) 的n次多项式来逼近函数的方法。</p></blockquote><p>泰勒公式的二阶展开形式如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/8bqfumtyy3.png"></span></div></figure><p>回到我们的问题上来， f(x) 对应于我们的损失函数 l ，x 对应于前 t-1 棵树的预测值，Δx 对应于我们正在训练的第 t 棵树。
</p><p>首先定义损失函数 l 关于 y‘(t-1) 的<code>一阶偏导数</code>和<code>二阶偏导数</code>：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/f6yl6qck9t.png"></span></div></figure><p>那么，我们的损失函数就可以转化为下式（标出了与泰勒公式中x和Δx的对应关系）。</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/9ib9emti5n.jpeg"></span></div></figure><p>将上述二阶展开式，带入到【2】中的目标函数 Obj 中，可以得到目标函数 Obj 的近似值：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/f8sg51mce4.png"></span></div></figure><p>去掉全部常数项，得到目标函数：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/5xhw84pn1p.jpeg"></span></div></figure><p>4. 定义一颗树
</p><p>我们重新定义一颗树，包括两个部分：</p><ul class="ul-level-0"><li>叶子结点的权重向量 ω ；</li><li>实例 -&gt; 叶子结点的映射关系q（本质是树的分支结构）；</li></ul><p>一棵树的表达形式定义如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/f0p4znmipy.jpeg"></span></div></figure><h3 id="5.-%E5%AE%9A%E4%B9%89%E6%A0%91%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6" name="5.-%E5%AE%9A%E4%B9%89%E6%A0%91%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><strong>5. 定义树的复杂度</strong></h3><p>我们定义一颗树的复杂度 Ω，它由两部分组成：</p><ul class="ul-level-0"><li>叶子结点的数量；</li><li>叶子结点权重向量的L2范数；</li></ul><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/aufhpsdzzq.jpeg"></span></div></figure><h3 id="6.-%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%BD%92%E7%BB%84" name="6.-%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E5%BD%92%E7%BB%84"><strong>6. 叶子结点归组</strong></h3><p>我们将属于第 j 个叶子结点的所有样本 xi , 划入到一个叶子结点样本集中，数学表示如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/j0iumkq2d8.png"></span></div></figure><p>然后，将【4】和【5】中一棵树及其复杂度的定义，带入到【3】中泰勒展开后的目标函数Obj中，具体推导如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/tkgkyhoxan.jpeg"></span></div></figure><p>为进一步简化该式，我们进行如下定义：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/h0r74kd0oj.png"></span></div></figure><p>含义如下：</p><ul class="ul-level-0"><li>Gj ：<strong>叶子结点 j 所包含样本</strong>的<code>一阶偏导数</code>累加之和，是一个常量；</li><li>Hj ：<strong>叶子结点 j 所包含样本</strong>的<code>二阶偏导数</code>累加之和，是一个常量；</li></ul><p>将 Gj 和 Hj 带入目标式Obj，得到我们<strong>最终的目标函数</strong>（注意，此时式中的变量只剩下第t棵树的权重向量W）：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/15dkfz90yx.png"></span></div></figure><h3 id="7.-%E6%A0%91%E7%BB%93%E6%9E%84%E6%89%93%E5%88%86" name="7.-%E6%A0%91%E7%BB%93%E6%9E%84%E6%89%93%E5%88%86"><strong>7. 树结构打分</strong></h3><p>回忆一下高中数学知识。假设有一个一元二次函数，形式如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/vmazik9s8d.jpeg"></span></div></figure><p>我们可以套用一元二次函数的<u><strong>最值公式</strong></u>轻易地求出最值点：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/w9j9r29kzl.png"></span></div></figure><p>那回到我们的目标函数 Obj，该如何求出它的最值呢？</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/bf0vjfq7fo.jpeg"></span></div></figure><p>先简单分析一下上面的式子：</p><p>对于每个叶子结点 j , 可以将其从目标式 Obj 中拆解出来：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/87z05cog0d.png"></span></div></figure><p>在【6】中我们提到，Gj 和 Hj 相对于第 t 棵树来说是可以计算出来的。那么，这个式子就是一个只包含一个变量 <strong>叶子结点权重wj</strong> 的一元二次函数，上面也提到了，我们可以通过最值公式求出它的最值点。</p><p>再次分析一下目标函数Obj，可以发现，各个叶子结点的目标子式是相互独立的，也就是说，当每个叶子结点的子式都达到最值点时，整个目标函数式Obj才达到最值点。</p><p>那么，假设目前树的结构已经固定，套用一元二次函数的<strong>最值公式</strong>，我们可以轻易求出，每个叶子结点的权重 wj* 及其此时达到最优的 Obj 的目标值：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/1xnnd009h2.jpeg"></span></div></figure><p><strong>实例演示：</strong> </p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/fbrkdgpx0y.jpeg"></span></div></figure><p><em style="font-style:italic"><strong>02</strong></em>
</p><p><strong>一棵树的生长细节</strong></p><h3 id="1.-%E5%88%86%E8%A3%82%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9" name="1.-%E5%88%86%E8%A3%82%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9"><strong>1. 分裂一个结点</strong></h3><p>在实际训练过程中，当建立第 t 棵树时，XGBoost采用贪心法进行树结点的分裂：</p><p>从树深为0时开始：</p><ul class="ul-level-0"><li>对树中的每个叶子结点尝试进行分裂；</li><li>每次分裂后，原来的一个叶子结点继续分裂为左右两个子叶子结点，原叶子结点中的样本集将根据该结点的判断规则分散到左右两个叶子结点中；</li><li>新分裂一个结点后，我们需要检测这次分裂是否会给损失函数带来增益，增益的定义如下：
</li></ul><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/z92iqsrv3a.jpeg"></span></div></figure><p>如果增益Gain&gt;0，即分裂为两个叶子节点后，目标函数下降了，那么我们会考虑此次分裂的结果。
</p><p>但是，在一个结点分裂时，可能有很多个分裂点，每个分裂点都会产生一个增益，如何才能寻找到最优的分裂点呢？接下来会讲到。</p><h3 id="2.-%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E5%88%86%E8%A3%82%E7%82%B9" name="2.-%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BD%B3%E5%88%86%E8%A3%82%E7%82%B9"><strong>2. 寻找最佳分裂点</strong></h3><p>在分裂一个结点时，我们会有很多个候选分割点，寻找最佳分割点的大致步骤如下：</p><ul class="ul-level-0"><li>遍历每个结点的每个特征；</li><li>对每个特征，按特征值大小将特征值排序；</li><li>线性扫描，找出每个特征的最佳分裂特征值；</li><li>在所有特征中找出最好的分裂点（分裂后增益最大的特征及特征值）</li></ul><p>上面是一种贪心的方法，每次进行分裂尝试都要遍历一遍全部候选分割点，也叫做全局扫描法。</p><p>但当数据量过大导致内存无法一次载入或者在分布式情况下，贪心算法的效率就会变得很低，全局扫描法不再适用。</p><p>基于此，XGBoost提出了一系列加快寻找最佳分裂点的方案：</p><ul class="ul-level-0"><li><strong>特征预排序+缓存：</strong>XGBoost在训练之前，预先对每个特征按照特征值大小进行排序，然后保存为block结构，后面的迭代中会重复地使用这个结构，使计算量大大减小。</li><li><strong>分位点近似法：</strong>对每个特征按照特征值排序后，采用类似分位点选取的方式，仅仅选出常数个特征值作为该特征的候选分割点，在寻找该特征的最佳分割点时，从候选分割点中选出最优的一个。</li><li><strong>并行查找：</strong>由于各个特性已预先存储为block结构，XGBoost支持利用多个线程并行地计算每个特征的最佳分割点，这不仅大大提升了结点的分裂速度，也极利于大规模训练集的适应性扩展。</li></ul><h3 id="3.-%E5%81%9C%E6%AD%A2%E7%94%9F%E9%95%BF" name="3.-%E5%81%9C%E6%AD%A2%E7%94%9F%E9%95%BF"><strong>3. 停止生长</strong></h3><p>一棵树不会一直生长下去，下面是一些常见的限制条件。</p><p>(1) 当新引入的一次分裂所带来的增益Gain&lt;0时，放弃当前的分裂。这是训练损失和模型结构复杂度的博弈过程。</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/7ebobxqsge.jpeg"></span></div></figure><p>(2) 当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数max_depth。</p><p>(3) 当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果任一个叶子结点的样本权重低于某一个阈值，也会放弃此次分裂。这涉及到一个超参数:最小样本权重和，是指如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细，这也是过拟合的一种措施。</p><p>每个叶子结点的样本权值和计算方式如下：</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/jggwst711w.png"></span></div></figure><p><em style="font-style:italic"><strong>03</strong></em>
</p><p><strong>高频面试题</strong></p><ul class="ul-level-0"><li>XGB与GBDT、随机森林等模型相比，有什么优缺点？</li><li>XGB为什么可以并行训练？</li><li>XGB用二阶泰勒展开的优势在哪？</li><li>XGB为了防止过拟合，进行了哪些设计？</li><li>XGB如何处理缺失值？</li><li>XGB如何分裂一个结点？如何选择特征？</li><li>XGB中一颗树停止生长的条件有哪些？</li><li>XGB叶子结点的权重有什么含义？如何计算？</li><li>训练一个XGB模型，经历了哪些过程？调参步骤是什么？</li><li>XGB如何给特征评分？</li></ul><p><em style="font-style:italic"><strong>04</strong></em>
</p><p><strong>备忘单</strong></p><p>经过前面几个部分的细心讲解，相信大家对XGBoost底层原理已经很了解了，下面特意又准备了一份备忘单，希望能够帮助大家系统化的掌握XGB原理的整个推导过程，同时又能够起到快速回忆的作用。</p><figure><div class="image-block"><span class="lazy-image-holder" dataurl="https://ask.qcloudimg.com/http-save/yehe-1478933/wm7trd7niq.jpeg"></span></div></figure></div>

&nbsp;  
## reference
[XGBoost超详细推导，终于讲明白了！](https://cloud.tencent.com/developer/article/1517020)  
[深入理解XGBoost](https://zhuanlan.zhihu.com/p/83901304)
